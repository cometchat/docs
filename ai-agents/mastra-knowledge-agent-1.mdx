---
title: "Build Your Knowledge Agent with Mastra"
description: "Create a Mastra agent that retrieves answers from local markdown docs (RAG‑lite), test it, deploy it, and connect it to CometChat."
canonical: "https://www.cometchat.com/docs/ai-agents/mastra-knowledge-agent"
---

Turn your product docs into a friendly chat teammate. This guide mirrors the Chef Agent format: you’ll start with a minimal OpenAI-only agent, add a lightweight knowledge tool (RAG‑lite) to read your Markdown docs, then connect the agent to CometChat.

---

import { Card, CardGroup, Callout, Steps, Tabs, Tab, Columns, Accordion, AccordionGroup, Icon } from 'mintlify';

<Callout>
This guide mirrors the **Chef Agent** walkthrough and swaps the domain for **knowledge retrieval**. You’ll build a minimal agent first, then add doc-based retrieval (RAG-lite), and finally connect it to **CometChat**.
</Callout>

## What You’ll Build

<CardGroup>
  <Card title="Mastra Agent" icon="/images/icons/mastra.svg">
    - A small agent powered by OpenAI.
    - Answers questions with short, accurate responses.
  </Card>
  <Card title="RAG-lite Retrieval">
    - Read local Markdown files as your knowledge base.
    - Return answers with a source list.
  </Card>
  <Card title="CometChat Integration" icon="/images/icons/ai-agents.svg">
    - Connect the agent in the dashboard using Agent ID + Deployment URL.
    - Use in 1:1 or group chats.
  </Card>
 </CardGroup>
---

<h3 className="text-2xl font-semibold mb-6 mt-8">
  <span className="inline-flex items-center px-4 py-1.5 rounded-full bg-emerald-100 text-emerald-700 dark:bg-emerald-900/30 dark:text-emerald-300 uppercase tracking-wide text-sm">Step 1</span>
</h3>

## Create Project & Docs (RAG-lite Base)

<Steps>
  <Step title="Scaffold app">Run <code>npx create-mastra@latest</code> and choose Express + OpenAI.</Step>
  <Step title="Set env">Add <code>OPENAI_API_KEY</code> to <code>.env</code>.</Step>
  <Step title="Add kb docs">Create <code>src/kb/</code> and add markdown files.</Step>
  <Step title="Review layout">Confirm generated structure matches below.</Step>
</Steps>

Project layout (condensed – scaffold + knowledge additions):
```txt
my-mastra-app/
  .env
  package.json
  tsconfig.json
  src/
    index.ts                # default entry (can keep or replace with Express app)
    mastra/
      index.ts              # Mastra instance (CLI expects this path)
    agents/
      weather-agent.ts      # scaffold example (optional)
      knowledge/
        agent.ts            # added
        retriever.ts        # added
    tools/
      weather-tool.ts       # scaffold example (optional)
      kb-retrieve.ts        # added
    workflows/
      weather-workflow.ts   # scaffold example (optional)
    kb/
      pricing.md            # added
      getting-started.md    # added
```

<Callout>
The scaffold ships a sample <code>weather</code> agent/tool/workflow. You can remove them or keep them alongside <code>knowledge</code>. Just ensure both are registered in <code>src/mastra/index.ts</code> if you keep weather.
</Callout>

<AccordionGroup>
  <Accordion title="Real Company Knowledge Setup (Optional – Recommended)">
Instead of (or in addition to) inline markdown snippets, point the agent at your **existing internal knowledge**. A lightweight ingestion pass keeps runtime fast and lets you redact sensitive data before exposure.

<b>Typical Sources</b>
<ul>
  <li>Product docs (Markdown, Docusaurus, GitBook exports)</li>
  <li>API specs (OpenAPI YAML)</li>
  <li>Runbooks / On‑call guides</li>
  <li>Support FAQs / Zendesk article exports (CSV → Markdown)</li>
  <li>Architecture decision records (ADR markdown)</li>
  <li>Sales / pricing one‑pagers (sanitize first!)</li>
</ul>

<b>Pipeline Stages</b>
<ol>
  <li><b>Collect:</b> Copy or export raw artifacts into <code>knowledge/raw</code>.</li>
  <li><b>Normalize:</b> Convert to Markdown or plain text.</li>
  <li><b>Chunk:</b> Split into semantically coherent sections (e.g., by h2/h3 headers, 1–3k chars).</li>
  <li><b>Annotate:</b> Add metadata: <code>category</code>, <code>tags</code>, <code>confidentiality</code>, <code>updatedAt</code>.</li>
  <li><b>Redact:</b> Remove keys, secrets, internal emails.</li>
  <li><b>Persist:</b> Save processed JSON lines for fast load.</li>
</ol>

<b>Extended Layout</b>
```txt
my-mastra-app/
  knowledge/
    raw/                 # unmodified exports
    processed/           # sanitized JSONL chunks
  scripts/
    ingest.ts            # one-off ingestion pipeline
```

<b>Ingestion Script</b> <code>scripts/ingest.ts</code>
```ts
import fs from 'fs';
import path from 'path';
import glob from 'fast-glob';
import matter from 'gray-matter';

interface ChunkInput { file: string; content: string; data: Record<string, any>; }
interface ChunkOutput {
  id: string; file: string; title: string; section: string; text: string;
  category?: string; tags?: string[]; updatedAt?: string; confidentiality?: string;
}

const RAW_DIR = path.join(process.cwd(), 'knowledge', 'raw');
const OUT_DIR = path.join(process.cwd(), 'knowledge', 'processed');
const MAX_CHARS = 2800; // simple size cap per chunk

function splitByHeading(body: string): string[] {
  return body.split(/\n(?=##?\s)/g).map(s => s.trim()).filter(Boolean);
}

function chunkSection(sec: string): string[] {
  if (sec.length <= MAX_CHARS) return [sec];
  const parts: string[] = [];
  let buf = '';
  for (const line of sec.split('\n')) {
    if ((buf + '\n' + line).length > MAX_CHARS) { parts.push(buf.trim()); buf = line; } else { buf += '\n' + line; }
  }
  if (buf.trim()) parts.push(buf.trim());
  return parts;
}

function processFile(file: string): ChunkOutput[] {
  const raw = fs.readFileSync(file, 'utf8');
  const { content, data } = matter(raw);
  const sections = splitByHeading(content);
  const fileBase = path.relative(RAW_DIR, file);
  const out: ChunkOutput[] = [];
  sections.forEach(sec => {
    const heading = sec.match(/^##?\s+(.+)$/m)?.[1]?.trim() || 'Introduction';
    chunkSection(sec).forEach((chunk, idx) => {
      out.push({
        id: `${fileBase}::${heading}::${idx}`,
        file: fileBase,
        title: data.title || fileBase.replace(/\.md$/i, ''),
        section: heading,
        text: chunk,
        category: data.category,
        tags: data.tags,
        updatedAt: data.updatedAt || new Date().toISOString(),
        confidentiality: data.confidentiality || 'public'
      });
    });
  });
  return out;
}

async function main() {
  if (!fs.existsSync(RAW_DIR)) throw new Error('RAW_DIR missing: ' + RAW_DIR);
  fs.mkdirSync(OUT_DIR, { recursive: true });
  const files = await glob('**/*.md', { cwd: RAW_DIR, absolute: true });
  let total = 0;
  const outPath = path.join(OUT_DIR, 'chunks.jsonl');
  const ws = fs.createWriteStream(outPath);
  for (const f of files) {
    const chunks = processFile(f);
    chunks.forEach(c => ws.write(JSON.stringify(c) + '\n'));
    total += chunks.length;
  }
  ws.end();
  console.log('Wrote', total, 'chunks to', outPath);
}

main().catch(e => { console.error(e); process.exit(1); });
```

<b>Hook Into Retriever</b>
Instead of scanning markdown at runtime, load the preprocessed JSONL once (faster + safer):
```ts
// Inside retriever.ts (optional replacement for loadSections())
import readline from 'readline';

let PRELOADED: any[] | null = null;
export function preload() {
  if (PRELOADED) return PRELOADED;
  const fp = path.join(process.cwd(), 'knowledge', 'processed', 'chunks.jsonl');
  if (!fs.existsSync(fp)) { PRELOADED = []; return PRELOADED; }
  PRELOADED = fs.readFileSync(fp, 'utf8').split(/\n/).filter(Boolean).map(l => JSON.parse(l));
  return PRELOADED;
}
```
Then adapt `retrieve` to use `preload()` records.

<b>Security & Redaction Checklist</b>
<ul>
  <li>Strip API keys / secrets (regex pass)</li>
  <li>Drop docs with <code>confidentiality: internal</code> before writing JSONL if serving externally</li>
  <li>Log source ids for every answer (audit)</li>
</ul>

  </Accordion>
</AccordionGroup>

Practical doc examples (create these under `src/kb/`). We use light frontmatter (YAML) so the retriever can filter/score by `category` & `tags`.

`src/kb/authentication.md`
```md
---
title: Authentication
category: backend
tags: [auth, token, security]
---
## Overview
All API calls require an App ID and a user auth token.

## Generate User Token
Call your backend to mint a short‑lived signed token for the user.

## SDK Init (JavaScript)
```ts
import { CometChat } from '@cometchat/chat-sdk';
await CometChat.init({ appId: 'APP_ID' });
```

## Login
```ts
await CometChat.login({ authToken: 'USER_AUTH_TOKEN' });
```
```

`src/kb/rate-limits.md`
```md
---
title: Rate Limits
category: operations
tags: [limits, throughput]
---
## Messaging
Soft cap: 60 messages / user / minute.
Burst handling: Excess queued briefly then dropped.

## Raise Limits
Contact support with recent peak metrics (5m, 1h windows).
```

`src/kb/groups.md`
```md
---
title: Groups
category: feature
tags: [groups, channels]
---
## Create Group
```ts
await CometChat.createGroup({ id: 'dev-hub', name: 'Dev Hub', type: 'public' });
```
## Add Member
```ts
await CometChat.addGroupMember({ groupId: 'dev-hub', userId: 'alice' });
```
## List Members
```ts
await CometChat.listGroupMembers({ groupId: 'dev-hub', limit: 50 });
```
```

`src/kb/ai-agents.md`
```md
---
title: AI Agents
category: ai
tags: [ai, agents, integration]
---
## Attach Agent
In dashboard, map Deployment URL to the Agent ID.

## Send Message To Agent
Agent participates like a normal user in the channel.
```

`src/kb/webhooks.md`
```md
---
title: Webhooks
category: integration
tags: [webhooks, callbacks]
---
## Delivery
Events sent with exponential backoff (max 4 retries).

## Secure
Validate the signature header (HMAC SHA256) using your shared secret.
```

<AccordionGroup>
  <Accordion title="Try these queries (copy/paste)">
```bash
# Auth flow
curl -s http://localhost:4111/api/agents/knowledge/generate \
  -H 'Content-Type: application/json' \
  -d '{"messages":[{"role":"user","content":"How do I initialize the JS SDK?"}]}' | jq '.output.text'

# Rate limit escalation
curl -s http://localhost:4111/api/agents/knowledge/generate \
  -H 'Content-Type: application/json' \
  -d '{"messages":[{"role":"user","content":"How can I raise message limits?"}]}' | jq '.output.text'

# Group operations
curl -s http://localhost:4111/api/agents/knowledge/generate \
  -H 'Content-Type: application/json' \
  -d '{"messages":[{"role":"user","content":"Show me the code to create a public group"}]}' | jq '.output.text'

# Webhooks security
curl -s http://localhost:4111/api/agents/knowledge/generate \
  -H 'Content-Type: application/json' \
  -d '{"messages":[{"role":"user","content":"How do I verify webhook authenticity?"}]}' | jq '.output.text'

# AI integration
curl -s http://localhost:4111/api/agents/knowledge/generate \
  -H 'Content-Type: application/json' \
  -d '{"messages":[{"role":"user","content":"How do I attach an AI agent?"}]}' | jq '.output.text'

# Fallback (should produce no-notes phrase)
curl -s http://localhost:4111/api/agents/knowledge/generate \
  -H 'Content-Type: application/json' \
  -d '{"messages":[{"role":"user","content":"Which database do you host on?"}]}' | jq '.output.text'
```
  </Accordion>
</AccordionGroup>

---

<h3 className="text-2xl font-semibold mb-6 mt-8">
  <span className="inline-flex items-center px-4 py-1.5 rounded-full bg-emerald-100 text-emerald-700 dark:bg-emerald-900/30 dark:text-emerald-300 uppercase tracking-wide text-sm">Step 2</span>
</h3>

## Create Retrieval Utility

Create **`src/agents/knowledge/retriever.ts`**:
```ts
import fs from 'fs';
import path from 'path';

// Resolve against project root so bundling / transpilation does not break relative paths.
const KB_DIR = path.join(process.cwd(), 'src', 'kb');

// --- Simple frontmatter + section parser ---
interface Section { file: string; title: string; section: string; content: string; meta: Record<string, any>; }

function tokenize(s: string) {
  return s.toLowerCase().replace(/[^a-z0-9\s]/g, ' ').split(/\s+/).filter(Boolean);
}

function score(query: string, text: string, boost = 1) {
  const qTokens = new Set(tokenize(query));
  const tTokens = tokenize(text);
  if (!tTokens.length) return 0;
  let hits = 0;
  for (const t of tTokens) if (qTokens.has(t)) hits++;
  return (hits / Math.sqrt(tTokens.length)) * boost;
}

function parseFrontmatter(raw: string) {
  if (!raw.startsWith('---')) return { meta: {}, body: raw };
  const end = raw.indexOf('\n---');
  if (end === -1) return { meta: {}, body: raw };
  const block = raw.slice(3, end).trim();
  const body = raw.slice(end + 4).trim();
  const meta: Record<string, any> = {};
  block.split(/\n/).forEach(line => {
    const m = line.match(/^([A-Za-z0-9_-]+):\s*(.*)$/);
    if (m) {
      const key = m[1].trim();
      let val: any = m[2].trim();
      if (val.startsWith('[') && val.endsWith(']')) {
        val = val.slice(1, -1).split(',').map(v => v.trim().replace(/^['"]|['"]$/g, ''));
      }
      meta[key] = val;
    }
  });
  return { meta, body };
}

function loadSections(): Section[] {
  if (!fs.existsSync(KB_DIR)) return [];
  const files = fs.readdirSync(KB_DIR).filter(f => f.endsWith('.md'));
  const sections: Section[] = [];
  for (const file of files) {
    const raw = fs.readFileSync(path.join(KB_DIR, file), 'utf8');
    const { meta, body } = parseFrontmatter(raw);
    const parts = body.split(/\n(?=##\s+)/g); // split on level-2 headings
    for (const p of parts) {
      const headingMatch = p.match(/^##\s+(.+)$/m);
      const sectionTitle = headingMatch ? headingMatch[1].trim() : '(root)';
      const content = p.trim();
      sections.push({ file, title: meta.title || file.replace(/\.md$/i, ''), section: sectionTitle, content, meta });
    }
  }
  return sections;
}

export function retrieve(query: string, topK = 4) {
  if (!query.trim()) return [];
  const secs = loadSections();
  return secs
    .map(s => {
      // boost matches in metadata
      const metaText = [s.title, s.meta.category, (s.meta.tags || []).join(' ')].filter(Boolean).join(' ');
      const baseScore = score(query, s.content);
      const metaScore = score(query, metaText, 1.4);
      return { ...s, _score: baseScore + metaScore };
    })
    .sort((a, b) => b._score - a._score)
    .slice(0, topK)
    .map(s => ({
      title: s.title,
      section: s.section,
      snippet: s.content.split(/\n/).slice(0, 12).join('\n') + (s.content.split(/\n/).length > 12 ? '\n...' : ''),
      tags: s.meta.tags || [],
    }));
}
```

---

<h3 className="text-2xl font-semibold mb-6 mt-8">
  <span className="inline-flex items-center px-4 py-1.5 rounded-full bg-emerald-100 text-emerald-700 dark:bg-emerald-900/30 dark:text-emerald-300 uppercase tracking-wide text-sm">Step 3</span>
</h3>

## Create Retrieval Tool

**`src/tools/kb-retrieve.ts`**:
```ts
import { createTool } from '@mastra/core/tools';
import { z } from 'zod';
import { retrieve } from '../agents/knowledge/retriever';

export const kbRetrieveTool = createTool({
  id: 'kb-retrieve',
  description: 'Return top matching knowledge base markdown docs.',
  inputSchema: z.object({ query: z.string().min(1) }),
  outputSchema: z.object({
    sources: z.array(z.object({
      title: z.string(),
      section: z.string(),
      snippet: z.string(),
      tags: z.array(z.string()).optional()
    }))
  }),
  execute: async ({ context }) => {
    const docs = retrieve(context.query, 3);
    return { sources: docs };
  }
});
```

---

<h3 className="text-2xl font-semibold mb-6 mt-8">
  <span className="inline-flex items-center px-4 py-1.5 rounded-full bg-emerald-100 text-emerald-700 dark:bg-emerald-900/30 dark:text-emerald-300 uppercase tracking-wide text-sm">Step 4</span>
</h3>

## Create the Agent

**`src/agents/knowledge/agent.ts`**:
```ts
import { Agent } from '@mastra/core/agent';
import { openai } from '@ai-sdk/openai';
import { kbRetrieveTool } from '../../tools/kb-retrieve';

export const knowledgeAgent = new Agent({
  name: 'knowledge',
  instructions: [
    'You are a precise knowledge agent for product docs.',
  'Always call the kb-retrieve tool FIRST to gather relevant sections based on the user question.',
  'If the docs do not contain the answer respond exactly: "I don\'t have that in my notes."',
  'Answer succinctly. After the answer output a Sources list with Title > Section for each source used.'
  ].join('\n'),
  model: openai('gpt-4o-mini'),
  tools: { 'kb-retrieve': kbRetrieveTool },
  // temperature or other model params can be added here if supported
});
```

---

<h3 className="text-2xl font-semibold mb-6 mt-8">
  <span className="inline-flex items-center px-4 py-1.5 rounded-full bg-emerald-100 text-emerald-700 dark:bg-emerald-900/30 dark:text-emerald-300 uppercase tracking-wide text-sm">Step 5</span>
</h3>

## Register the Agent in Mastra

**`src/mastra/index.ts`**:
```ts
import { Mastra } from '@mastra/core/mastra';
import { knowledgeAgent } from '../agents/knowledge/agent';

export const mastra = new Mastra({
  agents: {
  knowledge: knowledgeAgent,
  },
});

// Some tooling prefers a default export; keeping both is safe.
export default mastra;
```

> Key name `knowledge` defines the REST path: `/api/agents/knowledge/*`. The CLI resolves this file at `src/mastra/index.(ts|js)`.

---

<h3 className="text-2xl font-semibold mb-6 mt-8">
  <span className="inline-flex items-center px-4 py-1.5 rounded-full bg-emerald-100 text-emerald-700 dark:bg-emerald-900/30 dark:text-emerald-300 uppercase tracking-wide text-sm">Step 6</span>
</h3>

## Run the Agent

If you prefer a custom Express server instead of the scaffold's <code>src/index.ts</code>, create **`src/server.ts`**:
```ts
import express from 'express';
import bodyParser from 'body-parser';
import { mastra } from './mastra';

const app = express();
app.use(bodyParser.json());

app.post('/api/agents/knowledge/generate', async (req, res) => {
  try {
    const { messages = [] } = req.body || {};
    const result = await mastra.agents.knowledge.respond({ messages });
    res.json(result);
  } catch (e: any) {
    res.status(500).json({ error: e.message });
  }
});

const PORT = process.env.PORT || 4111;
app.listen(PORT, () => console.log(`Mastra API running on :${PORT}`));
```

Run & ping (either approach):
```bash
npx mastra dev                       # uses Mastra CLI runtime
# or (if you created server.ts and added a dev script) npm run dev
curl -s http://localhost:4111/api/agents/knowledge/generate \
  -H 'Content-Type: application/json' \
  -d '{"messages":[{"role":"user","content":"What’s included in pricing?"}]}' | jq .
```

---

<h3 className="text-2xl font-semibold mb-6 mt-8">
  <span className="inline-flex items-center px-4 py-1.5 rounded-full bg-emerald-100 text-emerald-700 dark:bg-emerald-900/30 dark:text-emerald-300 uppercase tracking-wide text-sm">Step 7</span>
</h3>

## Deploy & Production

<AccordionGroup>
  <Accordion title="Ping test">
```bash
curl -X POST http://localhost:4111/api/agents/knowledge/generate \
  -H 'Content-Type: application/json' \
  -d '{"messages":[{"role":"user","content":"ping"}]}'
```
  </Accordion>
  <Accordion title="Temporary public tunnel">
```bash
ngrok http 4111
cloudflared tunnel --url http://localhost:4111
loca.lt --port 4111
```
Append <code>/api/agents/knowledge/generate</code> and copy the HTTPS URL into the Dashboard.
  </Accordion>
  <Accordion title="Vercel serverless example (TypeScript)">
```ts
// api/agents/knowledge/generate.ts
import type { VercelRequest, VercelResponse } from '@vercel/node';
import { knowledgeAgent } from '../../../src/agents/knowledge/agent';

export default async function handler(req: VercelRequest, res: VercelResponse) {
  if (req.method !== 'POST') return res.status(405).json({ error: 'Method not allowed' });
  try {
    const { messages } = req.body || {};
    const result = await knowledgeAgent.respond({ messages });
    return res.status(200).json(result);
  } catch (e: any) {
    return res.status(500).json({ error: e.message || 'Agent error' });
  }
}
```
  </Accordion>
  <Accordion title="Production patterns">
    <ul>
      <li><b>Serverless:</b> One lightweight function per agent.</li>
      <li><b>Container:</b> Long‑lived process; add health checks & logging.</li>
      <li><b>Edge:</b> Keep retrieval tool stateless; externalize persistence.</li>
    </ul>
  </Accordion>
  <Accordion title="Security essentials">
    <ul>
      <li>Rate‑limit (per IP + user).</li>
      <li>Add auth (Bearer/JWT) for non-public usage.</li>
      <li>Log tool calls (name, duration, success/error).</li>
    </ul>
  </Accordion>
  <Accordion title="CometChat mapping">
    Deployment URL = public HTTPS endpoint + <code>/api/agents/knowledge/generate</code>. Mastra Agent ID = <code>knowledge</code>.
  </Accordion>
</AccordionGroup>

---

<h3 className="text-2xl font-semibold mb-6 mt-8">
  <span className="inline-flex items-center px-4 py-1.5 rounded-full bg-emerald-100 text-emerald-700 dark:bg-emerald-900/30 dark:text-emerald-300 uppercase tracking-wide text-sm">Step 8</span>
</h3>

## Configure in CometChat 
<Steps>
  <Step title="Open Dashboard">Open the <a href="https://app.cometchat.com/" target="_blank" rel="noreferrer">CometChat Dashboard</a>.</Step>
  <Step title="Navigate">App → <b>AI Agents</b>.</Step>
  <Step title="Add agent">Provider=Mastra, Agent ID=<code>knowledge</code>, Deployment URL=public generate endpoint.</Step>
  <Step title="(Optional) Enhancements">Add greeting & starter prompts.</Step>
  <Step title="Enable">Save and ensure status is <b>Enabled</b>.</Step>
</Steps>

---

<h3 className="text-2xl font-semibold mb-6 mt-8">
  <span className="inline-flex items-center px-4 py-1.5 rounded-full bg-emerald-100 text-emerald-700 dark:bg-emerald-900/30 dark:text-emerald-300 uppercase tracking-wide text-sm">Step 9</span>
</h3>

## Customize in Chat Builder
<Steps>
  <Step title="Open variant">From <b>AI Agents</b> click the variant (or Get Started).</Step>
  <Step title="Customize & Deploy">Select <b>Customize and Deploy</b>.</Step>
  <Step title="Adjust settings">Theme, layout, features; ensure the knowledge agent is attached.</Step>
  <Step title="Preview">Validate responses & sources display.</Step>
</Steps>

<Frame>
  <img src="/images/ai-agent-chat-builder-preview.png" />
</Frame>

---

## Integrate

Use the widget or UI kit. Display sources as reference chips.

<CardGroup>
  <Card title="Widget" href="/widget/ai-agents" icon="/images/icons/ai-agents.svg" description="Embed quickly with script" />
</CardGroup>

> The configured Mastra agent is already bundled—users can query it immediately.

---

## Test Your Setup

<Steps>
  <Step title="API responds">`/api/agents/knowledge/generate` returns an answer.</Step>
  <Step title="Tool invoked">Sources array present (tool executed).</Step>
  <Step title="Fallback phrase">Out-of-scope query returns: "I don't have that in my notes."</Step>
  <Step title="CometChat reply">Agent responds inside widget / chat builder variant.</Step>
</Steps>

```bash
curl -s http://localhost:4111/api/agents/knowledge/generate \
  -H 'Content-Type: application/json' \
  -d '{"messages":[{"role":"user","content":"What does Pro include?"}]}' | jq .
```

---

## Troubleshooting

- **Agent not found**: Verify `src/mastra/index.ts` exists, the `agents` map includes `knowledge`, then restart (`CTRL+C` + `npx mastra dev`). If you added the file after first run, remove `.mastra/output` to clear stale build.
- **No sources returned**: Ensure tool id `kb-retrieve` is registered & docs exist in `src/kb`.
- **Empty answers**: Add more docs or move to embeddings.
- **Auth / 401**: Verify `OPENAI_API_KEY`.

---

## Next Steps

- Swap retrieval for embeddings + vector DB (Pinecone, pgvector, LanceDB).
- Add guardrails / evals for hallucination reduction.
- Introduce additional tools (search, analytics) or workflows.
- Implement caching layer for frequent queries.

<Note>
Keep it simple: you now have an agent + retrieval. Upgrade later (vector DB, guardrails) without changing the CometChat steps.
</Note>
